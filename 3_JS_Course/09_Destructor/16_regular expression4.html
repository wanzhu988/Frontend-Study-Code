<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <script>
            /* 
                re.exec()
                    - 获取字符串中符合正则表达式的内容
            */
           let str = "abcaecafcacc"

           // 提取出str中符合axc格式的内容
        
           // i 代表忽略大小写，g 代表全局搜索，不会在找到第一个匹配后停止
           let re = /a(([a-z])c)/ig // 正则表达式匹配 'a' 后跟任意小写字母和 'c'

           let result = re.exec(str)
           //使用 exec() 方法尝试在字符串 str 中找到第一个匹配正则表达式的部分。exec() 方法返回一个数组，其中包含了匹配的结果以及任何捕获的分组。
        //    console.log(result)
            while(result){
                console.log(result[0], result[1], result[2])
                result = re.exec(str)
            }
            /*
                初始化匹配：首先，exec() 被调用一次来找到第一个匹配。如果找到了匹配，它返回一个数组，并设置 lastIndex。
                进入循环：如果 exec() 返回的不是 null（意味着有匹配发生），则进入 while 循环。
                循环体内的处理：在循环体内，你可以处理每个匹配的结果。这个例子中，打印了整个匹配和两个捕获组的内容。
                寻找下一个匹配：在循环的每个迭代的末尾，再次调用 exec() 来查找下一个匹配。由于 lastIndex 已经更新，它会从上一个匹配停止的地方开始查找。
                循环结束：如果没有更多的匹配项，exec() 将返回 null，导致 while 循环终止。
            */
            /* 
               正则表达式是 /a(([a-z])c)/ig，这里面有两个捕获组：
               - 第一个捕获组：(([a-z])c) 这个大括号捕获的是后面跟着的小写字母和 c 的组合，例如 abc 中的 bc。
               - 第二个捕获组：([a-z]) 这是嵌套在第一个捕获组内的小括号，它捕获的是单个小写字母，例如 abc 中的 b。

               使用 exec() 方法执行一个包含捕获组的正则表达式时，返回的结果数组将包括多个部分：
               - result[0]：这是整个匹配的部分，也就是正则表达式匹配的完整文本片段。
               - result[1], result[2], ...：这些是对应每个捕获组的匹配结果。
            
               对于匹配 abc：
               result[0] 将是 "abc"（整个匹配的字符串）。
               result[1] 将是 "bc"（第一个捕获组的内容）。
               result[2] 将是 "b"（第二个捕获组的内容，也就是第一个捕获组内部的小写字母）。
            */

        </script>
    </head>
    <body></body>
</html>
